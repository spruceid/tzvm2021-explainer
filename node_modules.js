require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],"just-debounce":[function(require,module,exports){
module.exports = debounce;

function debounce(fn, delay, atStart, guarantee) {
  var timeout;
  var args;
  var self;

  return function debounced() {
    self = this;
    args = Array.prototype.slice.call(arguments);

    if (timeout && (atStart || guarantee)) {
      return;
    } else if (!atStart) {
      clear();

      timeout = setTimeout(run, delay);
      return timeout;
    }

    timeout = setTimeout(clear, delay);
    fn.apply(self, args);

    function run() {
      clear();
      fn.apply(self, args);
    }

    function clear() {
      clearTimeout(timeout);
      timeout = null;
    }
  };
}

},{}],"querystring":[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":1,"./encode":2}],"rdf-nx-parser":[function(require,module,exports){
'use strict';
// ECMAScript 5

/**
 * @exports parser
 */
var parser = module.exports;


/**
 * This implementation relies heavily on regular expressions because they are
 * fast in V8: A lot faster than a previous implementation with a small state
 * machine that parsed the input string in a single scan. (Seems like regexes
 * can be compiled to machine code much more efficiently.)
 *
 * However, if speed is an issue, you should use a compiled parser like e.g.
 * [Raptor] [1] or [nxparser] [2]. Having a parser for Node.js is still great
 * for building tools etc.
 *
 *
 * Objects / typing: I decided to use plain JavaScript objects with a `type`
 * property for tokens instead of creating a constructor (class) for every token
 * type.
 *
 * The N-Triples grammar can be found at:
 * http://www.w3.org/TR/n-triples/#n-triples-grammar
 *
 *
 * [1]: http://librdf.org/raptor/
 * [2]: https://code.google.com/p/nxparser/
 */



var isCommentedOut = (function () {

	// Matches a comment (`#`) only at the beginning of a line
	var regexLeadingComment = /^\s*?#/;

	return function (text) {
		return regexLeadingComment.test(text) === true;
	};
})();



/**
 * Internal function to parse a triple or a quad.
 *
 * (Parsing is trivial: Just verify the number of tokens and create an object
 * from the tokens.)
 *
 *
 * @param {String} type  `quad` or `triple`
 *
 * @param {String|Array}  A string to parse or an array of token objects
 *                        (parsed).
 *
 * @param {Object}  [options]  Same options as `#tokenize`
 *
 * @return {Object|String}
 */
var _parse = (function () {


	return function (type, input, options) {

		// Tokenize
		var tokens;
		var tokenObjectsPassed = Array.isArray(input);

		if (tokenObjectsPassed) {
			tokens = input;
		}
		else {
			if (isCommentedOut(input)) {
				return null;
			}

			tokens = parser.tokenize(input, options);
		}


		// Parse tokens

		var expectedLength = type === 'quad' ? 5 : 4;
		// includes "end of statement"

		if (tokens.length !== expectedLength) {
			return null;
		}

		var result = {
			subject:   tokens[0],
			predicate: tokens[1],
			object:    tokens[2]
		};

		if (type === 'quad') {
			result.graphLabel = tokens[3];
		}

		return result;
	};
})();



// ---- Unicode handling -------------------------------------------------------

/**
 * Removes all Unicode escaping from a string.
 *
 * @return {String}
 */
var unescapeUnicode = (function () {

	// Matches `\Uxxxxxxxx` or `\uxxxx` (including the prefix)
	var regex = new RegExp('\\\\U[0-9a-fA-F]{8}|\\\\u[0-9a-fA-F]{4}', 'g');
	// (Don't use a regex literal here, because there were issues with
	// `String.prototype.replace` and regex flags in V8.)

	return function (string) {
		return string.replace(regex, decodeUcharToken);
	};
})();



/**
 * Unescapes all occurrences of special characters (tabs, backspace, etc.,
 * `ECHAR` tokens in the grammars) in a string.
 *
 *     ECHAR ::= '\' [tbnrf"'\]
 *
 * @param {String}
 * @return {String}
 */
var unescapeSpecialCharacters = (function() {

	var regex = /\\([tbnrf"'\\])/g;

	return function (literalString) {
		return literalString.replace(regex, '$1');
	};
})();



/**
 * Decodes a single Unicode escape sequence (a UCHAR token in the N-Triples
 * grammar).
 *
 *     UCHAR ::= '\u' HEX HEX HEX HEX | '\U' HEX HEX HEX HEX HEX HEX HEX HEX
 *
 * @param  {String} escapeString    Escaped Unicode string, including the escape
 *                                  sequence (`\U` or `\u`).
 */
function decodeUcharToken(escapeString) {

	// This assumes ECMAScript 5, which can't handle Unicode codepoints outside
	// the Basic Multilingual Plane (BMP) well.
	//
	// Workaround: Split "8-digit codepoints" (U+xxxxxxxx) into surrogate pairs.
	//
	// Still has some issues, like resulting in a "wrong" string length. See
	// `https://mathiasbynens.be/notes/javascript-unicode`
	//
	// This will be fixed in ECMAScript 6.


	if (escapeString[1] === 'u') {
		// `\u`

		// (Works with BMP codepoints only, U+0000 - U+FFFF.)
		return String.fromCharCode(Number('0x' + escapeString.slice(2)));
	}
	else {
		// `\U`

		// Workaround: Split codepoint into surrogate pair, then use
		// `String.fromCharCode`.
		var codepoint = parseInt(escapeString.slice(2), 16);

		if (codepoint <= 0x0000ffff) {
			// Is only padded, return codepoint from lower half.
			return String.fromCharCode(
				Number('0x' + escapeString.slice(6, 10))
			);
		}

		// Convert codepoint to a surrogate pair
		var h = Math.floor((codepoint - 0x10000) / 0x400) + 0xD800;
		var l = (codepoint - 0x10000) % 0x400 + 0xDC00;

		// Now get two characters from BLP codepoints
		return String.fromCharCode(h, l);
	}
	// (Other cases filtered by regex in `unescapeUnicode`.)
}




// -----------------------------------------------------------------------------
//      Exports
// -----------------------------------------------------------------------------


/**
 * Tokenizes a string.
 *
 * @param {String}  string   The String to tokenize.
 *
 * @param {Boolean} parsed   Set to `true` to return a parsed (plain JavaScript)
 *                           object.
 *
 * @return {Array}   Array of tokens, either strings or token objects, if
 *                   `parsed` is set to `true`.
 *
 * @param {Object}  [options]
 * @param {Boolean} [options.asStrings=false]
 * @param {Boolean} [options.includeRaw=false]  (If `asStrings` is `false`.)
 * @param {Boolean} [options.unescapeUnicode=true]
 *
 * @see #parseToken
 */
parser.tokenize = (function () {

	// This thing does most of this module's work. See `regex.md` for details.
	var splitTokensRegex = /((?:"[^"\\]*(?:\\.[^"\\]*)*"(?:@\w+(?:-\w+)?|\^\^<[^>]+>)?)|<[^>]+>|\_\:\w+|\.)/g;

	return function (string, options) {

		var tokens = string.match(splitTokensRegex);

		if (!tokens) {
			return null;
		}

		if (!(options && options.asStrings === true)) {
			// tokens = tokens.map(parser.parseToken);
			for (var i = 0; i < tokens.length; i++) {
				tokens[i] = parser.parseToken(tokens[i], options);
			}
		}

		return tokens;
	};

})();



/**
 * Transforms a raw "N-x element" string (part of a triple, quad, …) into a
 * token object (plain JavaScript object).
 *
 * Properties:
 *
 * - `type`: `iri`, `literal`, `blankNode` or `endOfStatement`
 * - `value` (without syntactic elements like brackets, quotes or `_:` prefixes)
 *
 * Optional additional properties for literals:
 *
 * - `language`:    The language tag (`…@language`)
 * - `datatypeIri`: The data type IRI (`…^^<IRI>`)
 *
 *
 * @param {String}  tokenString   Token string to parse.
 *
 * @param {Object}  [options]
 *
 * @param {Boolean} [options.includeRaw=false]
 *                  Keep the string input as property `valueRaw`
 *
 * @param {Boolean} [options.unescapeUnicode=true]
 *                  Decode escaped Unicode in literals.
 */
parser.parseToken = (function() {

	// Regex used to test for a literal suffix
	var regexLiteralSuffix = /\"(.*?)\"((?:@.*)|(?:\^\^<.*>))/;


	return function (tokenString, options) {
		var result = {};

		// Remove leading whitespace, if needed
		if (tokenString[0] === ' ') {
			tokenString = tokenString.trim();
		}

		if (options && options.includeRaw) {
			// Also keep the unprocessed string
			result.valueRaw = tokenString;
		}

		var skipUnicodeUnescaping = options &&
		                            options.unescapeUnicode === false;


		// Determine type (can be decided by looking at the first character) and
		// extract value
		switch (tokenString[0]) {
			case '<':
				result.type = 'iri';

				result.value = tokenString.slice(1, tokenString.length - 1);

				// Unescape: Only Unicode escapes (UCHAR) are allowed in IRIREF
				//           tokens, not special character escapes (ECHAR)

				if (!skipUnicodeUnescaping) {
					result.value = unescapeUnicode(result.value);
				}

				break;


			case '"':
				result.type = 'literal';

				// Check if literal has a suffix: Language tag or data type IRI

				var matches = tokenString.match(regexLiteralSuffix);
				if (matches) {
					result.value  = matches[1];

					var suffix = matches[2];
					if (suffix[0] === '@') {
						result.language = suffix.slice(1);
					} else {
						// slice: ^^<…>
						result.datatypeIri = suffix.slice(3, suffix.length - 1);
					}
				} else {
					result.value = tokenString.slice(1, tokenString.length - 1);
				}

				// Unescape

				result.value = unescapeSpecialCharacters(result.value);

				if (!skipUnicodeUnescaping) {
					result.value = unescapeUnicode(result.value);
				}

				break;


			case '_':
				result.type = 'blankNode';

				result.value = tokenString.slice(2);  // Remove `_:`
				break;


			case '.':
				result.type = 'endOfStatement';

				result.value = tokenString;
				break;
		}

		return result;
	};
})();



/**
 * @return {Array}   The set of token types as a string array.
 */
parser.getTokenTypes = (function () {

	var tokenTypes = [ 'iri', 'literal', 'blankNode', 'endOfStatement' ];
	Object.freeze(tokenTypes);

	return function () {
		return tokenTypes;
	};
})();



/**
 * Parses a triple from a string.
 *
 * @param {String}  input
 *
 * @param {Object}  [options]
 * @param {Boolean} [options.asStrings=false]
 * @param {Boolean} [options.includeRaw=false]  (Ignored if `parsed` is `false`)
 * @param {Boolean} [options.unescapeUnicode=true]
 *
 * @return {Object|null}
 */
parser.parseTriple = function (input, options) {

	return _parse('triple', input, options);
};



/**
 * Parses a quad from a string.
 *
 * @param {String}  input
 *
 * @param {Object}  [options]
 * @param {Boolean} [options.asStrings=false]
 * @param {Boolean} [options.includeRaw=false]  (Ignored if `parsed` is `false`)
 * @param {Boolean} [options.unescapeUnicode=true]
 *
 * @return {Object|null}
 */
parser.parseQuad = function (input, options) {

	return _parse('quad', input, options);
};

},{}]},{},[]);
